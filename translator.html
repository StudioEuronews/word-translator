<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Multilingual Translator Word</title>
    <script src="https://appsforoffice.microsoft.com/lib/1/hosted/office.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(45deg, #2196F3, #21CBF3);
            color: white;
            padding: 25px;
            text-align: center;
        }

        .header h1 {
            margin: 0;
            font-size: 1.8em;
            font-weight: 300;
        }

        .content {
            padding: 30px;
        }

        .language-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 25px;
        }

        .language-option {
            display: flex;
            align-items: center;
            padding: 8px;
            border-radius: 8px;
            transition: background-color 0.2s;
            cursor: pointer;
        }

        .language-option:hover {
            background-color: #f5f5f5;
        }

        .language-option input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }

        .language-option label {
            cursor: pointer;
            font-size: 0.9em;
            user-select: none;
        }

        .controls {
            margin-bottom: 25px;
        }

        .option-group {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .option-group h3 {
            margin: 0 0 10px 0;
            font-size: 1em;
            color: #555;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
        }

        .option-group h3 .toggle-icon {
            font-size: 0.8em;
            transition: transform 0.3s;
        }

        .option-group h3 .toggle-icon.collapsed {
            transform: rotate(-90deg);
        }

        .option-group.collapsed .option-content {
            display: none;
        }

        .checkbox-option {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .checkbox-option input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.1);
        }

        .checkbox-option label {
            cursor: pointer;
            font-size: 0.9em;
        }

        .translate-btn, .export-btn {
            width: 100%;
            color: white;
            border: none;
            padding: 15px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        .translate-btn {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }

        .export-btn {
            background: linear-gradient(45deg, #FF9800, #F57C00);
        }

        .translate-btn:hover, .export-btn:hover {
            transform: translateY(-2px);
        }

        .translate-btn:hover {
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
        }

        .export-btn:hover {
            box-shadow: 0 5px 15px rgba(255, 152, 0, 0.3);
        }

        .translate-btn:disabled, .export-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .progress-container {
            display: none;
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            width: 0%;
            transition: width 0.3s;
        }

        .progress-text {
            text-align: center;
            margin-top: 10px;
            font-size: 0.9em;
            color: #666;
        }

        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.9em;
            display: none;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .flag {
            margin-right: 5px;
            font-size: 1.1em;
            display: none;
        }

        .api-config {
            background: #f0f8ff;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #2196F3;
        }

        .input-group {
            margin-bottom: 12px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            font-weight: 500;
            color: #555;
        }

        .input-group input[type="password"],
        .input-group select {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e1e1e1;
            border-radius: 6px;
            font-size: 0.9em;
            transition: border-color 0.3s;
            box-sizing: border-box;
        }

        .input-group input[type="password"]:focus,
        .input-group select:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }

        .api-status {
            margin-top: 10px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85em;
            display: none;
        }

        .api-status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .api-status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .api-status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .ssml-export {
            background: #fff3e0;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #FF9800;
        }

        .ssml-export h4 {
            margin: 0 0 10px 0;
            color: #E65100;
            font-size: 0.9em;
        }

        .ssml-export p {
            margin: 0;
            font-size: 0.85em;
            color: #666;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåç Multilingual Translator</h1>
        </div>
        
        <div class="content">
            <div class="language-grid">
                <div class="language-option">
                    <input type="checkbox" id="fr" value="fr" checked>
                    <label for="fr">French</label>
                </div>
                <div class="language-option">
                    <input type="checkbox" id="de" value="de" checked>
                    <label for="de">German</label>
                </div>
                <div class="language-option">
                    <input type="checkbox" id="it" value="it" checked>
                    <label for="it">Italian</label>
                </div>
                <div class="language-option">
                    <input type="checkbox" id="es" value="es" checked>
                    <label for="es">Spanish</label>
                </div>
                <div class="language-option">
                    <input type="checkbox" id="pt" value="pt" checked>
                    <label for="pt">Portuguese</label>
                </div>
                <div class="language-option">
                    <input type="checkbox" id="ru" value="ru" checked>
                    <label for="ru">Russian</label>
                </div>
                <div class="language-option">
                    <input type="checkbox" id="el" value="el" checked>
                    <label for="el">Greek</label>
                </div>
                <div class="language-option">
                    <input type="checkbox" id="hu" value="hu" checked>
                    <label for="hu">Hungarian</label>
                </div>
                <div class="language-option">
                    <input type="checkbox" id="pl" value="pl" checked>
                    <label for="pl">Polish</label>
                </div>
                <div class="language-option">
                    <input type="checkbox" id="fa" value="fa" checked>
                    <label for="fa">Farsi</label>
                </div>
                <div class="language-option">
                    <input type="checkbox" id="ar" value="ar">
                    <label for="ar">Arabic</label>
                </div>
                <div class="language-option">
                    <input type="checkbox" id="tr" value="tr">
                    <label for="tr">Turkish</label>
                </div>
            </div>

            <div class="controls">
                <div class="option-group" id="azureGroup">
                    <h3 onclick="toggleSection('azureGroup')">
                        Azure Translator (Optional)
                        <span class="toggle-icon">‚ñº</span>
                    </h3>
                    <div class="option-content">
                        <div class="api-config">
                            <div class="input-group">
                                <label for="azureApiKey">API Key:</label>
                                <input type="password" id="azureApiKey" placeholder="Enter your Azure API key (optional)" />
                            </div>
                            <div class="input-group">
                                <label for="azureRegion">Region:</label>
                                <select id="azureRegion">
                                    <option value="westeurope">West Europe</option>
                                    <option value="eastus">East US</option>
                                    <option value="westus2">West US 2</option>
                                    <option value="southeastasia">Southeast Asia</option>
                                    <option value="northeurope">North Europe</option>
                                    <option value="centralus">Central US</option>
                                </select>
                            </div>
                            <div class="checkbox-option">
                                <input type="checkbox" id="saveApiKey">
                                <label for="saveApiKey">Remember my API key (stored locally)</label>
                            </div>
                            <div class="api-status" id="apiStatus"></div>
                        </div>
                    </div>
                </div>
                
                <div class="option-group">
                    <h3>Translation Options</h3>
                    <div class="option-content">
                        <div class="checkbox-option">
                            <input type="checkbox" id="preserveFormat" checked>
                            <label for="preserveFormat">Preserve layout</label>
                        </div>
                        <div class="checkbox-option">
                            <input type="checkbox" id="redText" checked>
                            <label for="redText">Translated text in red</label>
                        </div>
                        <div class="checkbox-option">
                            <input type="checkbox" id="newPage" checked>
                            <label for="newPage">New page per language</label>
                        </div>
                    </div>
                </div>
                
                <div class="option-group">
                    <h3>SSML Export Options</h3>
                    <div class="option-content">
                        <div class="ssml-export">
                            <h4>üé§ Azure Speech Service</h4>
                            <p>Export the entire document as a single SSML text file. Each language section will be announced in English, then read in the target language with specific voice settings.</p>
                        </div>
                    </div>
                </div>
            </div>

            <button class="translate-btn" onclick="startTranslation()">
                üöÄ Start Translation
            </button>
            
            <button class="export-btn" onclick="exportSSMLFiles()" id="exportBtn">
                üìÅ Export SSML File
            </button>

            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText"></div>
            </div>

            <div class="status" id="status"></div>
        </div>
    </div>

    <script>
        // Languages with specific voice configurations
        const languages = {
            'fr': { name: 'French', iso: 'FR', voice: 'fr-FR-VivienneMultilingualNeural', prosody: 'rate="-3.00%"', ssmlLang: 'fr-FR' },
            'de': { name: 'German', iso: 'DE', voice: 'de-DE-SeraphinaMultilingualNeural', prosody: '', ssmlLang: 'de-DE' },
            'it': { name: 'Italian', iso: 'IT', voice: 'it-IT-GiuseppeMultilingualNeural', prosody: 'pitch="low"', ssmlLang: 'it-IT' },
            'es': { name: 'Spanish', iso: 'ES', voice: 'es-ES-XimenaMultilingualNeural', prosody: 'pitch="low"', ssmlLang: 'es-ES' },
            'pt': { name: 'Portuguese', iso: 'PT', voice: 'pt-PT-RaquelNeural', prosody: '', ssmlLang: 'pt-PT' },
            'ru': { name: 'Russian', iso: 'RU', voice: 'ru-RU-DmitryNeural', prosody: '', ssmlLang: 'ru-RU' },
            'el': { name: 'Greek', iso: 'EL', voice: 'el-GR-NestorasNeural', prosody: '', ssmlLang: 'el-GR' },
            'hu': { name: 'Hungarian', iso: 'HU', voice: 'hu-HU-TamasNeural', prosody: '', ssmlLang: 'hu-HU' },
            'pl': { name: 'Polish', iso: 'PL', voice: 'pl-PL-MarekNeural', prosody: 'rate="-2.00%"', ssmlLang: 'pl-PL' },
            'fa': { name: 'Farsi', iso: 'FA', voice: 'fa-IR-FaridNeural', prosody: '', ssmlLang: 'fa-IR' },
            'ar': { name: 'Arabic', iso: 'AR', voice: 'ar-SA-HamedNeural', prosody: '', ssmlLang: 'ar-SA' },
            'tr': { name: 'Turkish', iso: 'TR', voice: 'tr-TR-AhmetNeural', prosody: '', ssmlLang: 'tr-TR' }
        };

        // English voice configuration
        const englishVoice = {
            name: 'English',
            iso: 'EN',
            voice: 'en-GB-RyanNeural',
            prosody: 'rate="-2.00%" pitch="low"',
            ssmlLang: 'en-GB'
        };

        // SSML word replacements by language
        const ssmlWordReplacements = {
            'fr': {
                'euronews': 'Euro Niouze', 
                'Euronews': 'Euro Niouze',
                'euronews.fr': 'Euro Niouze.fr', 
                'Euronews.fr': 'Euro Niouze.fr',
            },
            'pt': {
                'euronews.pt': 'EuroNews punto pt',
                'Euronews.pt': 'EuroNews punto pt',
            },
            'pl': {
                'Euronews': 'Euro News',
                'pl.euronews.com': 'pl kropka Euro News.com',
            }
            // Vous pouvez ajouter d'autres langues ici
            // 'de': {
            //     'example': 'Beispiel'
            // },
            // 'es': {
            //     'example': 'ejemplo'
            // }
        };

        // Store translated content for SSML export
        let translatedContent = {};

                // Apply SSML-specific word replacements
        function applySSMLReplacements(text, langCode) {
            let processedText = text;
            // Download processed text as a file
            downloadFile(processedText, `debug_04_processed_content_${langCode}.txt`); 
            // Remove complete URLs with http:// or https:// protocol
            // Keep simple domain names like euronews.com
            // Replace URLs with a space to avoid word collisions
            processedText = processedText.replace(/https?:\/\/[^\s\n\r<>]+/g, ' ');
            
            // Clean up multiple spaces but preserve line breaks
            processedText = processedText.replace(/[^\S\n\r]+/g, ' ');
            
            // Fix encoding issues - normalize Unicode characters
            processedText = processedText.normalize('NFC');
            
            // Replace problematic characters for SSML
            processedText = processedText
                // Replace typographic apostrophes with standard apostrophe
                .replace(/['']/g, "'")
                // Replace typographic quotes with standard quotes
                .replace(/[""]/g, '"')
                // Replace en/em dashes with standard hyphen
                .replace(/[‚Äì‚Äî]/g, '-')
                // Replace ellipsis character with three dots
                .replace(/‚Ä¶/g, '...')
                // Replace other problematic Unicode spaces
                .replace(/[\u00A0\u2000-\u200A\u202F\u205F\u3000]/g, ' ')
                // Fix common encoding artifacts
                .replace(/√Ñ‚Ä°/g, 'ƒá')
                .replace(/√Ñ/g, 'ƒç')
                .replace(/Vu√Ñi√Ñ‚Ä°/g, 'Vuƒçiƒá')
                .replace(/√Ñ/g, '≈°')
                .replace(/√Ñ/g, '≈æ')
                .replace(/√É¬©/g, '√©')
                .replace(/√É¬®/g, '√®')
                .replace(/√É¬°/g, '√°')
                .replace(/√É /g, '√†')
                .replace(/√É¬≠/g, '√≠')
                .replace(/√É¬≥/g, '√≥')
                .replace(/√É¬∫/g, '√∫')
                .replace(/√É¬ß/g, '√ß')
                .replace(/√É¬±/g, '√±')
                // Remove any remaining problematic control characters
                .replace(/[\u0000-\u001F\u007F-\u009F]/g, '');
            
            if (!ssmlWordReplacements[langCode]) {
                return processedText;
            }
            
            const replacements = ssmlWordReplacements[langCode];
            
            // Apply each replacement (case-insensitive)
            for (const [original, replacement] of Object.entries(replacements)) {
                // Use global case-insensitive regex
                const regex = new RegExp(original.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
                processedText = processedText.replace(regex, replacement);
            }
            
            console.log(`Applied SSML replacements for ${langCode}:`, Object.keys(replacements).length, 'replacements');
            return processedText;
        }

        // Generate complete SSML document with all languages
        function generateCompleteSSML(documentSections) {
            // Simplified SSML structure like the reference file
            let ssmlContent = '<speak xmlns="http://www.w3.org/2001/10/synthesis" xmlns:mstts="http://www.w3.org/2001/mstts" xmlns:emo="http://www.w3.org/2009/10/emotionml" version="1.0" xml:lang="en-GB">\n';
            
            for (let i = 0; i < documentSections.length; i++) {
                const section = documentSections[i];
                
                // Apply SSML-specific word replacements
                let processedContent = applySSMLReplacements(section.content, section.langCode);
                
                // Clean text for XML (preserve line breaks)
                const cleanText = processedContent
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                
                // Add the content in the target language with proper formatting
                const config = section.langCode === 'en' ? englishVoice : languages[section.langCode];
                
                if (config.prosody) {
                    ssmlContent += `<voice name="${config.voice}"><prosody ${config.prosody}>${cleanText}</prosody></voice>\n`;
                } else {
                    ssmlContent += `<voice name="${config.voice}">${cleanText}</voice>\n`;
                }
            }
            
            ssmlContent += '</speak>';
            return ssmlContent;
        }

        // Euronews URL mapping
        const euronewsUrls = {
            'en': 'euronews.com',
            'fr': 'euronews.fr',
            'de': 'euronews.de',
            'it': 'euronews.it',
            'es': 'euronews.es',
            'pt': 'euronews.pt',
            'ru': 'ru.euronews.com',
            'hu': 'euronews.hu',
            'el': 'gr.euronews.com',
            'pl': 'pl.euronews.com',
            'ar': 'arabic.euronews.com',
            'fa': 'parsi.euronews.com',
            'tr': 'tr.euronews.com'
        };

        // Toggle collapsible sections
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const icon = section.querySelector('.toggle-icon');
            
            section.classList.toggle('collapsed');
            icon.classList.toggle('collapsed');
        }

        // Clean text by removing EN line and adapting URLs
        function processTextForTranslation(text, targetLang) {
            // Remove standalone "EN" line at the beginning (keep other line breaks)
            let processedText = text.replace(/^EN\s*\n?/m, '');
            
            // Replace any euronews URL (with or without subdomain) with language-specific version
            if (euronewsUrls[targetLang]) {
                // Match any euronews URL pattern (with or without subdomain)
                processedText = processedText.replace(/(?:https?:\/\/)?(?:[a-z]+\.)?euronews\.com/g, euronewsUrls[targetLang]);
            }
            
            return processedText;
        }

        // Apply URL adaptation to translated text
        function adaptEuronewsUrls(text, targetLang) {
            if (euronewsUrls[targetLang]) {
                // Replace any euronews URL pattern in translated text
                return text.replace(/(?:https?:\/\/)?(?:[a-z]+\.)?euronews\.com/g, euronewsUrls[targetLang]);
            }
            return text;
        }

        // Generate SSML content with male and female voices
        function generateSSML(text, langCode) {
            const config = langCode === 'en' ? englishConfig : languages[langCode];
            if (!config) {
                console.error(`Configuration not found for language: ${langCode}`);
                return `<!-- Error: Configuration not found for ${langCode} -->`;
            }
            
            const cleanText = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');

            return `<?xml version="1.0" encoding="UTF-8"?><speak xmlns="http://www.w3.org/2001/10/synthesis" xmlns:mstts="http://www.w3.org/2001/mstts" xmlns:emo="http://www.w3.org/2009/10/emotionml" version="1.0" xml:lang="${config.ssmlLang}"><voice name="${config.voiceMale}"><prosody rate="+10.00%">${cleanText}</prosody></voice>
<break time="1s"/><voice name="${config.voiceFemale}"><prosody rate="+10.00%">${cleanText}</prosody></voice></speak>`;
        }

        // Download file function
        function downloadFile(content, filename, contentType = 'text/plain') {
            const blob = new Blob([content], { type: contentType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Export single SSML file with all languages
        async function exportSSMLFiles() {
            const button = document.getElementById('exportBtn');
            button.disabled = true;
            button.textContent = 'üìÅ Generating SSML...';

            try {
                const documentSections = [];
                let documentName = 'document_ssml'; // Default name

                await Word.run(async (context) => {
                    // Get document name - try multiple methods
                    try {
                        // Method 1: Try to get the document's file name
                        const file = context.document.properties;
                        file.load("title");
                        await context.sync();
                        
                        if (file.title && file.title.trim()) {
                            documentName = file.title.trim();
                            console.log('Document title found:', documentName);
                        } else {
                            // Method 2: Try to get from URL if available (Word Online)
                            if (window.location && window.location.href) {
                                const urlParams = new URLSearchParams(window.location.search);
                                const fileName = urlParams.get('file') || urlParams.get('filename');
                                if (fileName) {
                                    documentName = fileName.replace(/\.[^/.]+$/, ""); // Remove extension
                                    console.log('Document name from URL:', documentName);
                                }
                            }
                            
                            // Method 3: Try Office context if available
                            if (!documentName || documentName === 'document_ssml') {
                                try {
                                    if (Office && Office.context && Office.context.document && Office.context.document.url) {
                                        const url = Office.context.document.url;
                                        const urlParts = url.split('/');
                                        const fileNameWithExt = urlParts[urlParts.length - 1];
                                        if (fileNameWithExt && fileNameWithExt !== '') {
                                            documentName = fileNameWithExt.replace(/\.[^/.]+$/, ""); // Remove extension
                                            console.log('Document name from Office context:', documentName);
                                        }
                                    }
                                } catch (officeError) {
                                    console.log('Office context method failed:', officeError.message);
                                }
                            }
                            
                            // Method 4: Try document settings
                            if (!documentName || documentName === 'document_ssml') {
                                try {
                                    const settings = context.document.settings;
                                    settings.load();
                                    await context.sync();
                                    console.log('Checking document settings for name...');
                                } catch (settingsError) {
                                    console.log('Settings method failed:', settingsError.message);
                                }
                            }
                        }
                        
                        // Clean filename: remove invalid characters and decode if needed
                        documentName = documentName
                            .replace(/[<>:"/\\|?*]/g, '_')
                            .replace(/%20/g, ' ') // Replace URL encoded spaces
                            .trim();
                        
                        // If still default, try to extract from document content
                        if (documentName === 'document_ssml' || !documentName) {
                            const body = context.document.body;
                            body.load("text");
                            await context.sync();
                            
                            const firstLine = body.text.split('\n')[0].trim();
                            if (firstLine && firstLine.length > 0 && firstLine.length < 100) {
                                // Use first line as filename if it's reasonable length
                                documentName = firstLine.substring(0, 50).replace(/[<>:"/\\|?*]/g, '_');
                                console.log('Using first line as filename:', documentName);
                            }
                        }
                        
                    } catch (error) {
                        console.log('Could not get document name, using default:', error.message);
                        documentName = 'document_ssml';
                    }
                    
                    // Get all content from the document
                    const body = context.document.body;
                    body.load("text");
                    await context.sync();
                    
                    // Clean invisible control characters at the source
                    let fullText = body.text.replace(/[\u0000-\u001F\u007F-\u009F]/g, '');
                    console.log('Full document text length:', fullText.length);
                    
                    // Check if document has language markers
                    const languageMarkerRegex = /=== ([A-Z]+) ===/g;
                    const hasLanguageMarkers = languageMarkerRegex.test(fullText);
                    console.log('Document has language markers:', hasLanguageMarkers);
                    
                    if (hasLanguageMarkers) {
                        // Find all language markers and their positions
                        const markers = [];
                        const markerRegex = /=== ([A-Z]+) ===/g;
                        let match;
                        
                        while ((match = markerRegex.exec(fullText)) !== null) {
                            markers.push({
                                iso: match[1],
                                position: match.index,
                                fullMatch: match[0]
                            });
                            console.log(`Found marker: ${match[1]} at position ${match.index}`);
                        }
                        
                        // Extract English content (everything before first marker)
                        if (markers.length > 0) {
                            const englishContent = fullText.substring(0, markers[0].position).replace(/^[ \t]+|[ \t]+$/g, '');
                            if (englishContent) {
                                const processedContent = processTextForTranslation(englishContent, 'en');
                                documentSections.push({ langCode: 'en', content: processedContent });
                                console.log(`Added English section, length: ${processedContent.length}`);
                            }
                        }
                        
                        // Extract content for each language
                        for (let i = 0; i < markers.length; i++) {
                            const currentMarker = markers[i];
                            const nextMarker = markers[i + 1];
                            
                            // Calculate positions
                            const markerEndPos = currentMarker.position + currentMarker.fullMatch.length;
                            let startPos = markerEndPos;
                            
                            // Skip whitespace after marker
                            while (startPos < fullText.length && /\s/.test(fullText[startPos])) {
                                startPos++;
                            }
                            
                            const endPos = nextMarker ? nextMarker.position : fullText.length;
                            const content = fullText.substring(startPos, endPos).replace(/^[ \t]+|[ \t]+$/g, '');
                            
                            console.log(`Processing ${currentMarker.iso}: length=${content.length}`);
                            
                            if (content) {
                                let langCode = 'en';
                                
                                if (currentMarker.iso !== 'EN') {
                                    const foundLangCode = Object.keys(languages).find(code => 
                                        languages[code].iso === currentMarker.iso
                                    );
                                    if (foundLangCode) {
                                        langCode = foundLangCode;
                                    }
                                }
                                
                                documentSections.push({ langCode, content });
                                console.log(`Added ${currentMarker.iso} section`);
                            }
                        }
                    } else {
                        // No language markers - treat as single English document
                        console.log('No language markers found, treating as English');
                        const processedContent = processTextForTranslation(fullText, 'en');
                        documentSections.push({ langCode: 'en', content: processedContent });
                    }
                    
                    console.log('Total sections found:', documentSections.length);
                    console.log('Using filename:', documentName);
                    
                    if (documentSections.length === 0) {
                        throw new Error('No content found to export.');
                    }
                    // Log each section's language and content length
                    
                    // Generate complete SSML document
                    const completeSSML = generateCompleteSSML(documentSections);
                    
                    // Download single text file with document name
                    downloadFile(completeSSML, `${documentName}.txt`, 'text/plain');
                    
                    showStatus(`‚úÖ SSML file "${documentName}.txt" exported! Document with ${documentSections.length} sections downloaded.`, 'success');
                });
                
            } catch (error) {
                console.error('Export error:', error);
                showStatus(`‚ùå Export error: ${error.message}`, 'error');
            } finally {
                button.disabled = false;
                button.textContent = 'üìÅ Export SSML File';
            }
        }

        // Initialize Office
        Office.onReady((info) => {
            if (info.host === Office.HostType.Word) {
                console.log('Add-in loaded in Word');
                loadSavedApiKey();
            }
        });

        // Load saved API key from localStorage
        function loadSavedApiKey() {
            try {
                const savedKey = localStorage.getItem('azureApiKey');
                const savedRegion = localStorage.getItem('azureRegion');
                const saveKeyEnabled = localStorage.getItem('saveApiKey') === 'true';
                
                if (savedKey && saveKeyEnabled) {
                    document.getElementById('azureApiKey').value = savedKey;
                    document.getElementById('saveApiKey').checked = true;
                    showApiStatus('üîë API key loaded from saved settings', 'info');
                }
                
                if (savedRegion) {
                    document.getElementById('azureRegion').value = savedRegion;
                }
            } catch (error) {
                console.log('Could not load saved settings');
            }
        }

        // Save API key if user wants to remember it
        function saveApiKeyIfNeeded() {
            const apiKey = document.getElementById('azureApiKey').value.trim();
            const region = document.getElementById('azureRegion').value;
            const shouldSave = document.getElementById('saveApiKey').checked;
            
            try {
                if (shouldSave && apiKey) {
                    localStorage.setItem('azureApiKey', apiKey);
                    localStorage.setItem('azureRegion', region);
                    localStorage.setItem('saveApiKey', 'true');
                } else {
                    localStorage.removeItem('azureApiKey');
                    localStorage.removeItem('azureRegion');
                    localStorage.removeItem('saveApiKey');
                }
            } catch (error) {
                console.log('Could not save settings');
            }
        }

        function showApiStatus(message, type) {
            const status = document.getElementById('apiStatus');
            status.textContent = message;
            status.className = `api-status ${type}`;
            status.style.display = 'block';
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 5000);
        }

        async function startTranslation() {
            const selectedLanguages = getSelectedLanguages();
            
            if (selectedLanguages.length === 0) {
                showStatus('Please select at least one language.', 'error');
                return;
            }

            // Clear previous translated content
            translatedContent = {};

            // Save API key settings
            saveApiKeyIfNeeded();

            const button = document.querySelector('.translate-btn');
            button.disabled = true;
            button.textContent = '‚è≥ Translation in progress...';

            showProgress(true);

            try {
                await Word.run(async (context) => {
                    // Get document content
                    const body = context.document.body;
                    body.load("text,style");
                    await context.sync();

                    const originalText = body.text;
                    
                    if (!originalText.trim()) {
                        throw new Error('The document is empty.');
                    }

                    // Translate for each selected language
                    for (let i = 0; i < selectedLanguages.length; i++) {
                        const langCode = selectedLanguages[i];
                        const langName = languages[langCode].name;
                        
                        updateProgress((i / selectedLanguages.length) * 100, `Translating to ${langName}...`);
                        
                        try {
                            // Process text: remove EN line and adapt URLs
                            const processedText = processTextForTranslation(originalText, langCode);
                            
                            const translatedText = await translateText(processedText, langCode);
                            
                            // Store translated content for SSML export
                            translatedContent[langCode] = translatedText;
                            
                            await insertTranslation(context, translatedText, langName, langCode);
                        } catch (error) {
                            console.error(`Error translating to ${langName}:`, error);
                            await insertTranslation(context, `[Translation error for ${langName}]`, langName, langCode);
                        }
                    }

                    await context.sync();
                    updateProgress(100, 'Translation completed!');
                    
                    setTimeout(() => {
                        showProgress(false);
                        showStatus('Translation successful! The document has been updated.', 'success');
                        
                        // Remove the automatic export button show since it's always visible now
                    }, 1000);
                });

            } catch (error) {
                console.error('Error:', error);
                showStatus(`Error: ${error.message}`, 'error');
                showProgress(false);
            } finally {
                button.disabled = false;
                button.textContent = 'üöÄ Start Translation';
            }
        }

        async function insertTranslation(context, translatedText, langName, langCode) {
            const preserveFormat = document.getElementById('preserveFormat').checked;
            const redText = document.getElementById('redText').checked;
            const newPage = document.getElementById('newPage').checked;

            // Insert page break if requested
            if (newPage) {
                context.document.body.insertBreak(Word.BreakType.page, Word.InsertLocation.end);
            }

            // Insert language title with ISO code only
            const titleRange = context.document.body.insertText(`\n\n=== ${languages[langCode].iso} ===\n\n`, Word.InsertLocation.end);
            titleRange.font.bold = true;
            titleRange.font.size = 16;
            titleRange.font.color = '#2196F3';

            // Insert translated text
            const textRange = context.document.body.insertText(translatedText, Word.InsertLocation.end);
            
            if (redText) {
                textRange.font.color = '#FF0000';
            }

            // Apply formatting if requested
            if (preserveFormat) {
                textRange.font.size = 12;
                // Skip paragraphFormat.spaceAfter as it's not always available in Word Online
            }

            await context.sync();
        }

        async function translateText(text, targetLang) {
            // Get user's API configuration
            const userApiKey = document.getElementById('azureApiKey').value.trim();
            const userRegion = document.getElementById('azureRegion').value;
            
            // Limit text length to prevent excessive costs
            const MAX_CHARACTERS = 5000;
            if (text.length > MAX_CHARACTERS) {
                console.warn(`‚ö†Ô∏è Text too long (${text.length} chars). Truncating to ${MAX_CHARACTERS} chars.`);
                text = text.substring(0, MAX_CHARACTERS) + '...';
            }
            
            try {
                // Try Azure Translator if user provided API key
                if (userApiKey && userApiKey !== '') {
                    console.log('üîµ Trying Azure Translator with user key...');
                    
                    const response = await fetch(`https://api.cognitive.microsofttranslator.com/translate?api-version=3.0&to=${targetLang}`, {
                        method: 'POST',
                        headers: {
                            'Ocp-Apim-Subscription-Key': userApiKey,
                            'Ocp-Apim-Subscription-Region': userRegion,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify([{text: text}])
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        if (result && result[0] && result[0].translations && result[0].translations[0]) {
                            console.log('‚úÖ Azure Translator success');
                            showApiStatus('‚úÖ Azure Translator working perfectly!', 'success');
                            
                            // Apply Euronews URL adaptation to Azure translated text
                            const translatedText = adaptEuronewsUrls(result[0].translations[0].text, targetLang);
                            return translatedText;
                        }
                    } else {
                        console.warn('‚ö†Ô∏è Azure Translator error:', response.status, response.statusText);
                        if (response.status === 401) {
                            showApiStatus('‚ùå Invalid API key or region. Check your Azure credentials.', 'error');
                        } else if (response.status === 403) {
                            showApiStatus('‚ùå API quota exceeded or access denied.', 'error');
                        } else {
                            showApiStatus(`‚ùå Azure error: ${response.status}`, 'error');
                        }
                    }
                } else {
                    console.log('‚ÑπÔ∏è No Azure API key provided, using free service');
                }
            } catch (error) {
                console.log('‚ùå Azure Translator failed:', error.message);
                if (userApiKey) {
                    showApiStatus('‚ùå Connection error to Azure Translator', 'error');
                }
            }
            
            try {
                // Fallback: MyMemory service (free)
                console.log('üü° Using MyMemory fallback service...');
                
                const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=en|${targetLang}`);
                const data = await response.json();
                
                if (data.responseData && data.responseData.translatedText) {
                    console.log('‚úÖ MyMemory success');
                    if (!userApiKey) {
                        showApiStatus('‚ÑπÔ∏è Using free translation service. Add Azure key for better quality.', 'info');
                    }
                    
                    // Apply Euronews URL adaptation to translated text
                    const translatedText = adaptEuronewsUrls(data.responseData.translatedText, targetLang);
                    return translatedText;
                } else {
                    throw new Error('MyMemory service unavailable');
                }
            } catch (error) {
                console.log('‚ùå MyMemory failed:', error.message);
            }
            
            // Last resort: simulated text
            console.log('üî¥ Using fallback text simulation');
            return `[${languages[targetLang].name} Translation] ${text}`;
        }

        function getSelectedLanguages() {
            const checkboxes = document.querySelectorAll('.language-option input[type="checkbox"]:checked');
            return Array.from(checkboxes).map(cb => cb.value);
        }

        function showProgress(show) {
            const container = document.getElementById('progressContainer');
            container.style.display = show ? 'block' : 'none';
        }

        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.style.display = 'block';
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 5000);
        }
    </script>
</body>
</html>
